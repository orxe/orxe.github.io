{"version":3,"sources":["ids.ts","Home.tsx","App.tsx","reportWebVitals.ts","index.tsx","Orcs.ts"],"names":["ORCS_PROGRAM","anchor","PublicKey","process","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","TOKEN_METADATA_PROGRAM_ID","ConnectButton","styled","WalletDialogButton","CounterText","span","MintContainer","div","MintButton","Button","renderCounter","days","hours","minutes","seconds","completed","Home","props","useState","balance","setBalance","isActive","setIsActive","isSoldOut","setIsSoldOut","isMinting","setIsMinting","itemsRemaining","setItemsRemaining","open","message","severity","undefined","alertState","setAlertState","startDate","setStartDate","wallet","useAnchorWallet","orcs","setOrcs","price","setPrice","state","setState","onMint","a","program","config","console","log","mintOneToken","publicKey","treasury","mintTxId","awaitTransactionSignatureConfirmation","txTimeout","connection","status","err","msg","code","indexOf","getBalance","LAMPORTS_PER_SOL","useEffect","getOrcsState","orcsId","getWhitelistedUserPDA","whitelistPDA","getAccountInfo","whitelistPDAInfo","ORCS_DATA_ACCOUNT_ID","dataInfo","decodedOrcs","coder","accounts","decode","data","account","whitelistPdaUser","fetch","isTeamMember","teamWhitelistGoLiveDate","whitelistedPrice","whitelistGoLiveDate","goLiveDate","programId","toBase58","id","shortenAddress","toLocaleString","disabled","onClick","variant","CircularProgress","date","onMount","onComplete","renderer","Snackbar","autoHideDuration","onClose","Alert","network","Connection","startDateSeed","parseInt","REACT_APP_ORCS_START_DATE","theme","createTheme","palette","type","overrides","MuiButtonBase","root","justifyContent","MuiButton","textTransform","padding","startIcon","marginRight","endIcon","marginLeft","App","endpoint","useMemo","clusterApiUrl","wallets","getPhantomWallet","getSlopeWallet","getSolflareWallet","getSolletWallet","getSolletExtensionWallet","ThemeProvider","autoConnect","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","txid","timeout","commitment","queryStatus","done","slot","confirmations","subId","Promise","resolve","reject","setTimeout","onSignature","result","context","e","error","getSignatureStatuses","signatureStatuses","value","sleep","_signatureSubscriptions","removeSignatureListener","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","keys","pubkey","isSigner","isWritable","SystemProgram","TOKEN_PROGRAM_ID","SYSVAR_RENT_PUBKEY","TransactionInstruction","Buffer","from","anchorWallet","provider","preflightCommitment","JSON","response","text","idl","parse","itemsAvailable","toNumber","itemsRedeemed","configKey","dataUUID","uuid","Date","getMasterEdition","mint","findProgramAddress","toBuffer","getMetadata","user","getTokenWallet","orcsState","Keypair","generate","token","metadata","masterEdition","getMinimumBalanceForRentExemption","MintLayout","rent","configInfo","decoded","SYSVAR_CLOCK_PUBKEY","userPDAInfo","instructions","createAccount","fromPubkey","newAccountPubkey","space","lamports","Token","createInitMintInstruction","createMintToInstruction","fetchResult","nRedeemed","nRedeemable","whitelistedPubkey","rpc","mintNftWhitelisted","whitelistedUser","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","clock","signers","mintNft","Error","address","chars","slice","ms"],"mappings":"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","file":"static/js/main.7c66041e.chunk.js","sourcesContent":["import * as anchor from \"@project-serum/anchor\";\n\nexport const ORCS_PROGRAM = new anchor.web3.PublicKey(\n    process.env.REACT_APP_ORCS_PROGRAM_ID!\n);\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new anchor.web3.PublicKey(\n    \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\n);\n\nexport const TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n    \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n);","import {useEffect, useState} from \"react\";\nimport styled from \"styled-components\";\nimport Countdown from \"react-countdown\";\nimport {Button, CircularProgress, Snackbar} from \"@material-ui/core\";\nimport Alert from \"@material-ui/lab/Alert\";\n\nimport * as anchor from \"@project-serum/anchor\";\n\nimport {LAMPORTS_PER_SOL} from \"@solana/web3.js\";\n\nimport {useAnchorWallet} from \"@solana/wallet-adapter-react\";\nimport {WalletDialogButton} from \"@solana/wallet-adapter-material-ui\";\n\nimport {\n    Orcs, OrcsState,\n    awaitTransactionSignatureConfirmation,\n    getOrcsState,\n    mintOneToken,\n    shortenAddress, ORCS_DATA_ACCOUNT_ID, getWhitelistedUserPDA,\n} from \"./Orcs\";\n\nconst ConnectButton = styled(WalletDialogButton)``;\n\nconst CounterText = styled.span``; // add your styles here\n\nconst MintContainer = styled.div``; // add your styles here\n\nconst MintButton = styled(Button)``; // add your styles here\n\nexport interface HomeProps {\n    orcsId: anchor.web3.PublicKey;\n    connection: anchor.web3.Connection;\n    startDate: number;\n    treasury: anchor.web3.PublicKey;\n    txTimeout: number;\n}\n\nconst Home = (props: HomeProps) => {\n    const [balance, setBalance] = useState<number>();\n    const [isActive, setIsActive] = useState(false); // true when countdown completes\n    const [isSoldOut, setIsSoldOut] = useState(false); // true when items remaining is zero\n    const [isMinting, setIsMinting] = useState(false); // true when user got to press MINT\n    const [itemsRemaining, setItemsRemaining] = useState<number>(0);\n\n    const [alertState, setAlertState] = useState<AlertState>({\n        open: false,\n        message: \"\",\n        severity: undefined,\n    });\n\n    const [startDate, setStartDate] = useState<Date>();\n\n    const wallet = useAnchorWallet();\n    const [orcs, setOrcs] = useState<Orcs>();\n    const [price, setPrice] = useState<number>();\n    const [state, setState] = useState<OrcsState>();\n\n    const onMint = async () => {\n        try {\n            setIsMinting(true);\n            if (wallet && orcs?.program && state?.config) {\n                console.log(`About to mint one token!`);\n                const mintTxId = await mintOneToken(\n                    state,\n                    wallet.publicKey,\n                    props.treasury\n                );\n                console.log(`got mint tx id ${mintTxId}`);\n\n                const status = await awaitTransactionSignatureConfirmation(\n                    mintTxId,\n                    props.txTimeout,\n                    props.connection,\n                    \"singleGossip\",\n                    false\n                );\n\n                if (!status?.err) {\n                    setAlertState({\n                        open: true,\n                        message: \"Congratulations! Mint succeeded!\",\n                        severity: \"success\",\n                    });\n                } else {\n                    setAlertState({\n                        open: true,\n                        message: \"Mint failed! Please try again!\",\n                        severity: \"error\",\n                    });\n                }\n            }\n        } catch (error: any) {\n            // TODO: blech:\n            console.log(error);\n            let message = error.msg || \"Minting failed! Please try again!\";\n            if (!error.msg) {\n                if (error.message.indexOf(\"0x138\")) {\n                } else if (error.message.indexOf(\"0x137\")) {\n                    message = `SOLD OUT!`;\n                } else if (error.message.indexOf(\"0x135\")) {\n                    message = `Insufficient funds to mint. Please fund your wallet.`;\n                }\n            } else {\n                if (error.code === 311) {\n                    message = `SOLD OUT!`;\n                    setIsSoldOut(true);\n                } else if (error.code === 312) {\n                    message = `Minting period hasn't started yet.`;\n                }\n            }\n\n            setAlertState({\n                open: true,\n                message,\n                severity: \"error\",\n            });\n        } finally {\n            if (wallet) {\n                const balance = await props.connection.getBalance(wallet.publicKey);\n                setBalance(balance / LAMPORTS_PER_SOL);\n            }\n            setIsMinting(false);\n        }\n    };\n\n    useEffect(() => {\n        (async () => {\n            if (wallet) {\n                const balance = await props.connection.getBalance(wallet.publicKey);\n                setBalance(balance / LAMPORTS_PER_SOL);\n            }\n        })();\n    }, [wallet, props.connection]);\n\n    useEffect(() => {\n        (async () => {\n            if (!wallet) return;\n\n            const state = await getOrcsState(wallet as anchor.Wallet, props.orcsId, props.connection);\n\n            const whitelistPDA = (await getWhitelistedUserPDA(wallet.publicKey, state))[0];\n            const whitelistPDAInfo = await state.orcs.connection.getAccountInfo(whitelistPDA);\n\n            setState(state);\n            setIsSoldOut(state.itemsRemaining === 0);\n            setOrcs(state.orcs);\n            setItemsRemaining(state.itemsRemaining);\n\n            const dataInfo = await state.orcs.connection.getAccountInfo(ORCS_DATA_ACCOUNT_ID);\n            if(dataInfo) {\n                const decodedOrcs = state.orcs.program.coder.accounts.decode(\"Orcs\", dataInfo.data);\n                if (whitelistPDAInfo) {\n                    const whitelistFetchResult = await state.orcs.program.account.whitelistPdaUser.fetch(whitelistPDA);\n                    if (whitelistFetchResult.data.isTeamMember) {\n                        setPrice(0);\n                        setStartDate(state.teamWhitelistGoLiveDate);\n                        setAlertState({open: true, message: \"Recognized as team member\", severity: \"success\", });\n                    } else {\n                        setPrice(decodedOrcs.data.whitelistedPrice / LAMPORTS_PER_SOL);\n                        setStartDate(state.whitelistGoLiveDate);\n                        setAlertState({open: true, message: \"Recognized as whitelisted user\", severity: \"success\", });\n                    }\n                } else {\n                    setPrice(decodedOrcs.data.price / LAMPORTS_PER_SOL);\n                    setStartDate(state.goLiveDate);\n                }\n\n                console.log(`Got go live date ${state.goLiveDate}`);\n                console.log(`Got state program ${state.orcs.program.programId.toBase58()}`);\n                console.log(`Got state id ${state.orcs.id.toBase58()}`);\n                console.log(`Got state connection ${state.orcs.connection}`);\n            }\n\n        })();\n    }, [wallet, props.orcsId, props.connection]);\n\n    return (\n        <main>\n            {wallet && (\n                <p>Address: {shortenAddress(wallet.publicKey.toBase58() || \"\")}</p>\n            )}\n\n            {wallet && (\n                <p>Balance: {(balance || 0).toLocaleString()} SOL</p>\n            )}\n            {wallet && state && (\n                <p>Go live date: {state.goLiveDate.toLocaleString()}</p>\n            )}\n            {wallet && state && (\n                <p>Whitelisted go live date: {state.whitelistGoLiveDate.toLocaleString()}</p>\n            )}\n            {wallet && state && (\n                <p>Team go live date: {state.teamWhitelistGoLiveDate.toLocaleString()}</p>\n            )}\n\n            <MintContainer>\n                {!wallet ? (\n                    <ConnectButton>Connect Wallet</ConnectButton>\n                ) : (\n                    <MintButton\n                        disabled={isSoldOut || isMinting || !isActive}\n                        onClick={onMint}\n                        variant=\"contained\"\n                    >\n                        {isSoldOut ? (\n                            \"SOLD OUT\"\n                        ) : isActive ? (\n                            isMinting ? (\n                                <CircularProgress/>\n                            ) : (\n                                `MINT for ${price} SOL (${itemsRemaining} remaining)`\n                            )\n                        ) : (\n                            <Countdown\n                                date={startDate}\n                                onMount={({completed}) => completed && setIsActive(true)}\n                                onComplete={() => setIsActive(true)}\n                                renderer={renderCounter}\n                            />\n                        )}\n                    </MintButton>\n                )}\n            </MintContainer>\n\n            <Snackbar\n                open={alertState.open}\n                autoHideDuration={6000}\n                onClose={() => setAlertState({...alertState, open: false})}\n            >\n                <Alert\n                    onClose={() => setAlertState({...alertState, open: false})}\n                    severity={alertState.severity}\n                >\n                    {alertState.message}\n                </Alert>\n            </Snackbar>\n        </main>\n    );\n};\n\ninterface AlertState {\n    open: boolean;\n    message: string;\n    severity: \"success\" | \"info\" | \"warning\" | \"error\" | undefined;\n}\n\nconst renderCounter = ({days, hours, minutes, seconds, completed}: any) => {\n    return (\n        <CounterText>\n            {hours} hours, {minutes} minutes, {seconds} seconds\n        </CounterText>\n    );\n};\n\nexport default Home;\n","import \"./App.css\";\nimport {useMemo} from \"react\";\n\nimport Home from \"./Home\";\n\nimport * as anchor from \"@project-serum/anchor\";\nimport {clusterApiUrl} from \"@solana/web3.js\";\nimport {WalletAdapterNetwork} from \"@solana/wallet-adapter-base\";\nimport {\n    getPhantomWallet,\n    getSlopeWallet,\n    getSolflareWallet,\n    getSolletWallet,\n    getSolletExtensionWallet,\n} from \"@solana/wallet-adapter-wallets\";\n\nimport {\n    ConnectionProvider,\n    WalletProvider,\n} from \"@solana/wallet-adapter-react\";\n\nimport {WalletDialogProvider} from \"@solana/wallet-adapter-material-ui\";\nimport {createTheme, ThemeProvider} from \"@material-ui/core\";\n\nimport React, { useState, useEffect } from 'react';\n\nconst treasury = new anchor.web3.PublicKey(\n    process.env.REACT_APP_TREASURY_ADDRESS!\n);\n\nconst orcsId = new anchor.web3.PublicKey(\n    process.env.REACT_APP_ORCS_DATA_ACCOUNT_ID!\n);\n\nconst network = process.env.REACT_APP_SOLANA_NETWORK as WalletAdapterNetwork;\n\nconst rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST!;\nconst connection = new anchor.web3.Connection(rpcHost);\n\nconst startDateSeed = parseInt(process.env.REACT_APP_ORCS_START_DATE!, 10);\n\nconst txTimeout = 3000000; // milliseconds (confirm this works for your project)\n\nconst theme = createTheme({\n    palette: {\n        type: 'dark',\n    },\n    overrides: {\n        MuiButtonBase: {\n            root: {\n                justifyContent: 'flex-start',\n            },\n        },\n        MuiButton: {\n            root: {\n                textTransform: undefined,\n                padding: '12px 16px',\n            },\n            startIcon: {\n                marginRight: 8,\n            },\n            endIcon: {\n                marginLeft: 8,\n            },\n        },\n    },\n});\n\nconst App = () => {\n    const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n    const wallets = useMemo(\n        () => [\n            getPhantomWallet(),\n            getSlopeWallet(),\n            getSolflareWallet(),\n            getSolletWallet({network}),\n            getSolletExtensionWallet({network})\n        ],\n        []\n    );\n\n    return (\n        <ThemeProvider theme={theme}>\n            <ConnectionProvider endpoint={endpoint}>\n                <WalletProvider wallets={wallets} autoConnect>\n                    <WalletDialogProvider>\n                        <Home\n                            orcsId={orcsId}\n                            connection={connection}\n                            startDate={startDateSeed}\n                            treasury={treasury}\n                            txTimeout={txTimeout}\n                        />\n                    </WalletDialogProvider>\n                </WalletProvider>\n            </ConnectionProvider>\n        </ThemeProvider>\n    );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import * as anchor from \"@project-serum/anchor\";\nimport {MintLayout, Token, TOKEN_PROGRAM_ID,} from \"@solana/spl-token\";\nimport {\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    TOKEN_METADATA_PROGRAM_ID,\n    ORCS_PROGRAM,\n} from \"./ids\";\nimport {PublicKey} from \"@solana/web3.js\";\n\nexport const ORCS_DATA_ACCOUNT_ID = new anchor.web3.PublicKey(\n    process.env.REACT_APP_ORCS_DATA_ACCOUNT_ID!\n);\n\nexport interface Orcs {\n    id: anchor.web3.PublicKey,\n    connection: anchor.web3.Connection;\n    program: anchor.Program;\n}\n\nexport interface OrcsState {\n    orcs: Orcs;\n    itemsAvailable: number;\n    itemsRedeemed: number;\n    itemsRemaining: number;\n    goLiveDate: Date,\n    whitelistGoLiveDate: Date,\n    teamWhitelistGoLiveDate: Date,\n    config: PublicKey,\n    uuid: string\n}\n\nexport const awaitTransactionSignatureConfirmation = async (\n    txid: anchor.web3.TransactionSignature,\n    timeout: number,\n    connection: anchor.web3.Connection,\n    commitment: anchor.web3.Commitment = \"recent\",\n    queryStatus = false\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n    let done = false;\n    let status: anchor.web3.SignatureStatus | null | void = {\n        slot: 0,\n        confirmations: 0,\n        err: null,\n    };\n    let subId = 0;\n    status = await new Promise(async (resolve, reject) => {\n        setTimeout(() => {\n            if (done) {\n                return;\n            }\n            done = true;\n            console.log(\"Rejecting for timeout...\");\n            reject({timeout: true});\n        }, timeout);\n        try {\n            subId = connection.onSignature(\n                txid,\n                (result: any, context: any) => {\n                    done = true;\n                    status = {\n                        err: result.err,\n                        slot: context.slot,\n                        confirmations: 0,\n                    };\n                    if (result.err) {\n                        console.log(\"Rejected via websocket\", result.err);\n                        reject(status);\n                    } else {\n                        console.log(\"Resolved via websocket\", result);\n                        resolve(status);\n                    }\n                },\n                commitment\n            );\n        } catch (e) {\n            done = true;\n            console.error(\"WS error in setup\", txid, e);\n        }\n        while (!done && queryStatus) {\n            // eslint-disable-next-line no-loop-func\n            (async () => {\n                try {\n                    const signatureStatuses = await connection.getSignatureStatuses([\n                        txid,\n                    ]);\n                    status = signatureStatuses && signatureStatuses.value[0];\n                    if (!done) {\n                        if (!status) {\n                            console.log(\"REST null result for\", txid, status);\n                        } else if (status.err) {\n                            console.log(\"REST error for\", txid, status);\n                            done = true;\n                            reject(status.err);\n                        } else if (!status.confirmations) {\n                            console.log(\"REST no confirmations for\", txid, status);\n                        } else {\n                            console.log(\"REST confirmation for\", txid, status);\n                            done = true;\n                            resolve(status);\n                        }\n                    }\n                } catch (e) {\n                    if (!done) {\n                        console.log(\"REST connection error: txid\", txid, e);\n                    }\n                }\n            })();\n            await sleep(2000);\n        }\n    });\n\n    //@ts-ignore\n    if (connection._signatureSubscriptions[subId]) {\n        await connection.removeSignatureListener(subId);\n    }\n    done = true;\n    console.log(\"Returning status\", status);\n    return status;\n}\n\nconst createAssociatedTokenAccountInstruction = (\n    associatedTokenAddress: anchor.web3.PublicKey,\n    payer: anchor.web3.PublicKey,\n    walletAddress: anchor.web3.PublicKey,\n    splTokenMintAddress: anchor.web3.PublicKey\n) => {\n    const keys = [\n        {pubkey: payer, isSigner: true, isWritable: true},\n        {pubkey: associatedTokenAddress, isSigner: false, isWritable: true},\n        {pubkey: walletAddress, isSigner: false, isWritable: false},\n        {pubkey: splTokenMintAddress, isSigner: false, isWritable: false},\n        {\n            pubkey: anchor.web3.SystemProgram.programId,\n            isSigner: false,\n            isWritable: false,\n        },\n        {pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false},\n        {\n            pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n            isSigner: false,\n            isWritable: false,\n        },\n    ];\n    return new anchor.web3.TransactionInstruction({\n        keys,\n        programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n        data: Buffer.from([]),\n    });\n}\n\nexport const getOrcsState = async (\n    anchorWallet: anchor.Wallet,\n    orcsId: anchor.web3.PublicKey,\n    connection: anchor.web3.Connection,\n): Promise<OrcsState> => {\n    const provider = new anchor.Provider(connection, anchorWallet, {\n        preflightCommitment: \"recent\",\n    });\n\n    const idl = JSON.parse(await fetch('idl/orcs.json').then(response => response.text()));\n    const program = new anchor.Program(idl, ORCS_PROGRAM, provider);\n    const orcs = {\n        id: orcsId,\n        connection: connection,\n        program: program,\n    }\n\n    const state: any = await program.account.orcs.fetch(ORCS_DATA_ACCOUNT_ID);\n    const itemsAvailable = state.data.itemsAvailable.toNumber();\n    const itemsRedeemed = state.itemsRedeemed.toNumber();\n    const configKey: PublicKey = state.config;\n    const dataUUID: string = state.data.uuid;\n    const itemsRemaining = itemsAvailable - itemsRedeemed;\n\n    let goLiveDate = state.data.goLiveDate.toNumber();\n    goLiveDate = new Date(goLiveDate * 1000);\n\n    const whitelistGoLiveDate = new Date(state.data.whitelistGoLiveDate.toNumber() * 1000);\n    const teamWhitelistGoLiveDate = new Date(state.data.teamWhitelistGoLiveDate.toNumber() * 1000);\n\n    return {\n        orcs: orcs,\n        itemsAvailable: itemsAvailable,\n        itemsRedeemed: itemsRedeemed,\n        itemsRemaining: itemsRemaining,\n        goLiveDate: goLiveDate,\n        whitelistGoLiveDate: whitelistGoLiveDate,\n        teamWhitelistGoLiveDate: teamWhitelistGoLiveDate,\n        config: configKey,\n        uuid: dataUUID\n    };\n}\n\nconst getMasterEdition = async (\n    mint: anchor.web3.PublicKey\n): Promise<anchor.web3.PublicKey> => {\n    return (\n        await anchor.web3.PublicKey.findProgramAddress(\n            [\n                Buffer.from(\"metadata\"),\n                TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n                mint.toBuffer(),\n                Buffer.from(\"edition\"),\n            ],\n            TOKEN_METADATA_PROGRAM_ID\n        )\n    )[0];\n};\n\nconst getMetadata = async (\n    mint: anchor.web3.PublicKey\n): Promise<anchor.web3.PublicKey> => {\n    return (\n        await anchor.web3.PublicKey.findProgramAddress(\n            [\n                Buffer.from(\"metadata\"),\n                TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n                mint.toBuffer(),\n            ],\n            TOKEN_METADATA_PROGRAM_ID\n        )\n    )[0];\n};\n\nexport const getWhitelistedUserPDA = async (user: anchor.web3.PublicKey, state: any) => {\n    return await PublicKey.findProgramAddress(\n        [Buffer.from(\"orcs\"), state.config.toBuffer(), Buffer.from(state.uuid), user.toBuffer()],\n        ORCS_PROGRAM,\n    );\n}\n\nconst getTokenWallet = async (\n    wallet: anchor.web3.PublicKey,\n    mint: anchor.web3.PublicKey\n) => {\n    return (\n        await anchor.web3.PublicKey.findProgramAddress(\n            [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n            SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n        )\n    )[0];\n};\n\nexport function uuidFromPubkey(configAccount: anchor.web3.PublicKey) {\n    return configAccount.toBase58().slice(0, 6);\n}\n\nexport const mintOneToken = async (\n    orcsState: OrcsState,\n    payer: anchor.web3.PublicKey,\n    treasury: anchor.web3.PublicKey,\n): Promise<string> => {\n    const orcs = orcsState.orcs;\n    const mint = anchor.web3.Keypair.generate();\n    const token = await getTokenWallet(payer, mint.publicKey);\n    const connection = orcs.connection;\n    const program = orcs.program;\n    const metadata = await getMetadata(mint.publicKey);\n    const masterEdition = await getMasterEdition(mint.publicKey);\n\n    const rent = await connection.getMinimumBalanceForRentExemption(\n        MintLayout.span\n    );\n\n    const configInfo = await connection.getAccountInfo(new anchor.web3.PublicKey(orcs.id));\n    if (configInfo) {\n        const decoded = program.coder.accounts.decode(\"Orcs\", configInfo.data);\n        const configKey = new anchor.web3.PublicKey(decoded.config);\n\n        console.log(`PROGRAM ${program}`)\n        console.log(`about to mint nft w/ config ${configKey}`)\n        console.log(`about to mint nft w/ orcs ${orcs.id}`)\n        console.log(`about to mint nft w/ payer ${payer}`)\n        console.log(`about to mint nft w/ wallet ${treasury}`)\n        console.log(`about to mint nft w/ metadata ${metadata}`)\n        console.log(`about to mint nft w/ mint ${mint.publicKey}`)\n        console.log(`about to mint nft w/ mintAuthority ${payer}`)\n        console.log(`about to mint nft w/ updateAuthority ${payer}`)\n        console.log(`about to mint nft w/ masterEdition ${masterEdition}`)\n        console.log(`about to mint nft w/ tokenMetadataProgram ${TOKEN_METADATA_PROGRAM_ID}`)\n        console.log(`about to mint nft w/ tokenProgram ${TOKEN_PROGRAM_ID}`)\n        console.log(`about to mint nft w/ systemProgram ${anchor.web3.SystemProgram.programId}`)\n        console.log(`about to mint nft w/ rent ${anchor.web3.SYSVAR_RENT_PUBKEY}`)\n        console.log(`about to mint nft w/ clock ${anchor.web3.SYSVAR_CLOCK_PUBKEY}`)\n\n        console.log(\"Got state:\", orcsState);\n        const whitelistPDA = (await getWhitelistedUserPDA(payer, orcsState))[0];\n        console.log(\"Got whitelistPDA\", whitelistPDA.toBase58());\n        const userPDAInfo = await orcs.connection.getAccountInfo(whitelistPDA);\n\n        const instructions = [\n            anchor.web3.SystemProgram.createAccount({\n                fromPubkey: payer,\n                newAccountPubkey: mint.publicKey,\n                space: MintLayout.span,\n                lamports: rent,\n                programId: TOKEN_PROGRAM_ID,\n            }),\n            Token.createInitMintInstruction(TOKEN_PROGRAM_ID, mint.publicKey, 0, payer, payer),\n            createAssociatedTokenAccountInstruction(token, payer, payer, mint.publicKey),\n            Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint.publicKey, token, payer, [], 1),\n        ]\n\n        const fetchResult = userPDAInfo ? await program.account.whitelistPdaUser.fetch(whitelistPDA) : null;\n        if (fetchResult) {\n            console.log(\"Whitelist PDA got owner\");\n            console.log(\"n redeemed:\", fetchResult.data.nRedeemed.toNumber());\n            console.log(\"n redeemable:\", fetchResult.data.nRedeemable.toNumber());\n            console.log(\"whitelistedPubkey:\", fetchResult.data.whitelistedPubkey.toBase58());\n            console.log(\"config\", fetchResult.config.toBase58(), \"with UUID\", fetchResult.data.uuid);\n        } else {\n            console.log(\"Whitelist PDA account info was null\");\n        }\n        if (userPDAInfo && fetchResult && fetchResult.data.nRedeemed < fetchResult.data.nRedeemable) {\n\n            return await program.rpc.mintNftWhitelisted({\n                accounts: {\n                    config: configKey,\n                    orcs: orcs.id,\n                    whitelistedUser: whitelistPDA,\n                    payer: payer,\n                    wallet: treasury,\n                    metadata: metadata,\n                    mint: mint.publicKey,\n                    mintAuthority: payer,\n                    updateAuthority: payer,\n                    masterEdition: masterEdition,\n                    tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n                    tokenProgram: TOKEN_PROGRAM_ID,\n                    systemProgram: anchor.web3.SystemProgram.programId,\n                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n                    clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n                },\n                signers: [mint],\n                instructions: instructions\n            });\n        } else {\n            return await program.rpc.mintNft({\n                accounts: {\n                    config: configKey,\n                    orcs: orcs.id,\n                    payer: payer,\n                    wallet: treasury,\n                    metadata: metadata,\n                    mint: mint.publicKey,\n                    mintAuthority: payer,\n                    updateAuthority: payer,\n                    masterEdition: masterEdition,\n                    tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n                    tokenProgram: TOKEN_PROGRAM_ID,\n                    systemProgram: anchor.web3.SystemProgram.programId,\n                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n                    clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n                },\n                signers: [mint],\n                instructions: instructions\n            });\n        }\n\n    } else {\n        throw new Error(\"Could not get account info for orcs program id.\")\n    }\n}\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n    return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"],"sourceRoot":""}